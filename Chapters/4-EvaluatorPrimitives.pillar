!! Primitive Operations

Our interpreter does not yet handle many essential behavior that prevent us to evaluate complex programs.
This chapter introduces the concept of primitive methods in Pharo.
We call primitive behavior the behaviour that needs to be implemented in the interpreter or evaluator because it cannot be purely expressed in the programming language, Pharo in this case.
Let's consider for example the operation of adding up two numbers (==\+==).
We cannot express in a pure and concise way a normal method executing an addition.
Along with arithmetics, other examples of primitive operations are object allocation and reflective object access.
Such primitive behavior in Pharo is expressed as special methods, namely ""primitive methods"" in Pharo, whose behavior is defined in the interpreter or evaluator.

Differently from languages such as Java or C, that express arithmetics as special operators that are compiled/interpreted differently, Pharo maintains the message-send metaphore for primitive behaviour. Indeed, in Pharo ==\+== is a message, which triggers a look-up and a method activation. This separation makes redefining operators as simple as implementing a method with the selector ==\+== in our own class, without the need for special syntax for it.

In addition of essential behaviour, primitive behaviour can be used to implement performance-critical code in a much more efficient way, since primitives are implemented in the implementation language and do not suffer the interpretation overhead.

In this chapter we will study how primitive methods work, and how they should be properly implemented, including the evaluation of their fallback code. We will then visit some of the essential primitives we need to make work to execute complex examples.


!!! Primitives in Pharo

In Pharo the design of primitives is split in three different parts: messages, primitive methods, and the primitive itself which is provided by the interpreter. The first thing to note is that in Pharo programs primitive behavior is invoked through standard message sends. This allows developers to define operators as non-primitives on their own classes, by just implementing methods with the corresponding selectors and without any additional syntax. With some terminology abuse we could think of this as "operator redefinition", although it is no such, it is just a standard method re/definition. This operator redefinition feature is useful for example when creating internal domain specific languages (DSLs), or to have polymorphism between integers and floats.

[[[
MyClass >> + anArgument [
  "Redefine +"
  ...
]
]]]

To define primitive behavior, Pharo relies on special methods called primitive methods.
Primitive methods are normal Pharo methods with a special ==primitive== annotation.
For example, let us consider the code snipped below, which is an excerpt of the ==SmallInteger>>\+== method.
This method looks like a normal method with selector ==\+==, and with a normal method body doing ==^super \+ aNumber==.
The only difference between this method and a normal one is that this method also has an annotation, or pragma, indicating that it is the primitive number 1.

[[[
SmallInteger >> + aNumber [
	<primitive: 1>
	^ super + aNumber
]
]]]

Before diving into how primitive methods are executed, let us introduce the third component in place: the interpreter primitives.
The interpreter or evaluator, defines a set of supported primitives with unique ids.
In our case for example, the primitive with id ==1== implements the behavior that adds up two integers.

When a primitive method is activated, it first looks-up what primitive to execute from its primitive id number, and executes it.
The primitive performs some validations if required, executes the corresponding behavior, and returns either with a success if everything went ok, or a failure if there was a problem. If the execution was a success, the method execution returns with the value computed by the primitive. If the execution was a failure, the body of the method is executed instead. Because of this, the body of a primitive method is also named the "fall-back code".

!!! Implementing Primitive Methods

To implementing primitives in our evaluator we need to only change how methods are activated.
Indeed, as we have seen above, the method lookup nor other special nodes are required for the execution, and the AST already supports pragma nodes, which we need to extract the method's primitive id.

Inside the activation of a method, we need to look for the primitive to execute, and check for failures.
A simple way to implement the primitives is as methods in our evaluator.
We then need to map primitive ids to those methods in our evaluator.
We will implement such mapping using a table with the form ==<id, evaluator_selector>==.
Upon primitive method execution, we extract the primitive id from the pragma, get the selector of that id from the table, and use ==perform:== on the interpreter with that selector to execute the primitive.
We need to also take care of sending the receiver and arguments of the message to the primitive, so it can manipulate them.

Let's start by setting up our testing scenario: adding up two numbers.
We make sure to work with small enough numbers in this test, to not care about primitive failures yet.
Doing ==1 \+ 5== the primitive should always be a success and return `6`.

[[[
CHInterpreter >> initialize [
  	super initialize. 
  	stack := Stack new.
  	primitives := Dictionary new.
  	self initializePrimitiveTable.
]

CHInterpreter >> initializePrimitiveTable [
	primitives at: 1 put: #primitiveSmallIntegerAdd
]


]]]

[[[
CHInterpretable >> smallintAdd [
	^ 1 + 5
]

CHInterpreterTests >> testSmallIntAddPrimitive [
  	self
      assert: (self executeSelector: #smallintAdd)
      equals: 6
]
]]]

In our first iteration we will not care about optimizing our evaluator, for which we had already and we will have tons of opportunities.
To have a simple implementation to work on we will start by executing the primitive after creating the method's frame, in the ==visitMethodNode:== method.
This way the primitive has a simple way to access the receiver and the arguments by reading the frame.
We will leave primitive failures management for our second iteration.

[[[
CHInterpreter >> visitMethodNode: aMethodNode [	
	aMethodNode isPrimitive ifTrue: [ 
		"Do not handle primitive failures for now"
		^ self executePrimitiveMethod: aMethodNode ].
	
	^ self visitNode: aMethodNode body
]

CHInterpreter >> executePrimitiveMethod: anAST [
	| primitiveNumber |
	primitiveNumber := anAST pragmas
		detect: [ :each | each isPrimitive ]
		ifFound: [ :aPragmaPrimitive | aPragmaPrimitive arguments first value ]
		ifNone: [ self error: 'Not a primitive method' ].
		
	^ self perform: (primitives at: primitiveNumber)
]

CHInterpreter >> primitiveSmallIntegerAdd [
	| receiver argument |
	receiver := self receiver.
	argument := self argumentAt: 1.
	^ receiver + argument
]

CHInterpreter >> argumentAt: anInteger [
  ^ self tempAt: (self currentMethod arguments at: anInteger) name
]
]]]

!!! Primitive Failures and Fallback Code

Let's now consider what should happen when a primitive fails.
For example, following Pharo's specification, primitive 1 fails when the receiver or the argument are not small integers, or whenever their sum overflows and does not fit into a small integer anymore.
To produce one of such failing cases, we can implement primitive 1 in our ==CHInterpretable== class, which should fail because the receiver should be a small integer. When it fails, the fallback code should execute.

[[[
CHInterpretable >> failingPrimitive [
  <primitive: 1>
  ^ 'failure'
]

CHInterpretable >> callingFailingPrimitive [
  ^ self failingPrimitive
]

CHInterpreterTests >> testFailingPrimitive [
  	self
      assert: (self executeSelector: #callingFailingPrimitive)
      equals: 'failure'
]
]]]

To add primitive failures in a clean way, let's introduce them as exceptions.
In our primitive, if we detect a failure condition, we will raise a ==CHPrimitiveFail== error.
We then need to modify the way we evaluate methods to handle ==CHPrimitiveFail== exceptions and continue evaluating the body.

[[[
CHInterpreter >> primitiveSmallIntegerAdd [
	| receiver argument |
	receiver := self receiver.
	receiver class = SmallInteger
		ifFalse: [ CHPrimitiveFail signal ].

	argument := self argumentAt: 1.
	^ receiver + argument
]

CHInterpreter >> argumentAt: anInteger [
	^ self tempAt: (self currentMethod arguments at: anInteger) name
]

CHInterpreter >>visitMethodNode: aMethodNode [
	[aMethodNode isPrimitive ifTrue: [ 
		"Do not handle primitive failures for now"
		^ self executePrimitiveMethod: aMethodNode ]]
		on: CHPrimitiveFail do: [ :err | 
			"Nothing, just continue with the method body" ].
	
	^ self visitNode: aMethodNode body
]
]]]

With these changes, everything should work fine now.
  
!!!! Typical Primitive Failure Cases

For primitives to work properly, and for Pharo to be a safe language, primitives should properly do a series of checks.
This is specially important when the interpreter fully controls all other aspects of the language, such as the memory.
In such cases, primitives, as well as the other parts of the evaluator, have full power over our objects, potentially producing memory corruptions.

Among the basic checks that primitives should do, they should not only verify that arguments are of the primitive's expected type, as we have shown above. A general check to do in addition is that the primitive was called with the right number of arguments. This check is particularly important because developers may wrongly define primitives such as we did before, where we have defined a unary method, in other words with no arguments, using a primitive that expects one argument. If we don't properly check the arguments trying to access it could cause an interpreter failure, while the proper behaviour should be to just fail the primitive and let the fallback code carry on the execution.

[[[
CHInterpretable >> failingPrimitive [
  <primitive: 1>
  ^ 'failure'
]
]]]

!!! Essential Primitives

In this section we will implement a series of essential primitives, that will make it possible to execute a large range of Pharo programs.

!!!! Arithmetic Primitives

Some examples of \+, /.

!!!! Object Allocation Primitives

Show normal object allocation #basicNew, and allocation of a variable object #basicNew:.

!!! Conclusion

This 
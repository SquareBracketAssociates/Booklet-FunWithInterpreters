!! Message Sends: Calling Infrastructure

In the previous chapter we focused on structural evaluation: reading literal objects and reading and writing values from objects and globals. However, the key abstraction in object-oriented programming and in Pharo in particular is message-sending. 
The work we did in the previous chapter is nevertheless important to set up the stage: we have a better taste of the visitor pattern, we started a first testing infrastructure, and eventually message-sends need to carry out some work by using literal objects or reading and writing variables.

Message-sends deserve a chapter on their own because they introduce many different concerns. 
On the one hand, each message-send is resolved in two steps: first the method-lookup searches in the receiver's hierarchy the method to be executed, and second that method is applied on the receiver (i.e., it is evaluated with self bound to the receiver). 
On the other hand, each method application needs to set up an execution context to store the receiver, arguments and temporary variables for that specific method execution.
These execution contexts form the execution stack or call-stack.
Sending a message pushes a new context in the call-stack, returning from a method pops a context from the call-stack.
This is mechanics that we will cover in this chapter, so that in the following chapter we can implement logic and support late-binding.


!!! Introduction to Stack Management

The way we managed the receiver so far is overly simplistic.
Indeed, each time a program will send a message to another object, we should change the receiver and when the computation ends, the previous receiver should be put back. Moreover, the same happens with method arguments and temporaries. Therefore to introduce the notion of message-send we need a stack. And each element in the stack needs to capture all the execution state require to come back to it later on when a message-send will return. Each element in the call-stack is usually named a stack frame, an activation record, or in Pharo's terminology a context. For the rest of this book we will refer to them as frames, for shortness, and to distinguish them from the reified contexts from Pharo.

A first step to introduce stack management without breaking all our previous tests is to replace the single ==receiver== instance variable with a stack that will be initialized when the evaluator is created. The top of the stack will represent the current execution, and thus we will take the current receiver at each moment from the stack top. Moreover, each time we tell our interpreter to execute something we need to initialize our stack with a single frame.

@@todo add a diagram here with the stack

[[[caption=Replace the receiver instance variable by a stack
Object subclass: #CHInterpreter
	instanceVariableNames: 'stack'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpreter >> initialize [
	super initialize. 
	stack := CTStack new.
]
]]]

With this new schema, we can now rewrite the access to the receiver to just access the value of ==#self== of the top frame. 

[[[language=pharo
CHInterpreter >> receiver [
	^ self topFrame receiver
]

CHInterpreter >> topFrame [
	^ stack top
]
]]]

The final step is to set up a frame when the execution starts, which happened so far in our method ==execute:withReceiver:==. We extend the ==execute:withReceiver:== to create a new frame and define the receiver as ==#self== in the top frames before start the evaluation.

[[[language=pharo
CHInterpreter >> execute: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame receiver: anObject.
	^ self visitNode: anAST
]
]]]

The last piece in the puzzle is the method ==pushNewFrame==, which creates a new frame and pushes it on the top of the stack. 
Since methods define a scope with their temporary variables and arguments, we represent frames using a new kind of scope: a method scope.
The method scope will for now store the current receiver, and later its parent scope, and a set of key-value pairs representing the variables defined in the current method execution: the arguments and temporaries.

[[[
CHInterpreter >> pushNewFrame [
	| newTop |
	newTop := CHMethodScope new.
	stack push: newTop.
	^ newTop
]

Object subclass: #CHMethodScope
	instanceVariableNames: 'receiver variables'
	classVariableNames: ''
	package: 'Champollion-Core'

CHMethodScope >> receiver: aCHInterpretable [
	receiver := aCHInterpretable
]

CHMethodScope >> receiver [
	^ receiver
]
]]]

This refactor kept all the test green, and opened the path to introduce message-sends.
As the reader may have observed, this stack can only grow.
We will take care of popping frames from the stack later when we revisit method returns.

!!! Evaluating a First Message Send

Let's start as usual by defining a new method exhibiting the scenario we want to work on.
In this case, we want to start by extending our evaluator to correctly evaluate return values of message sends.

Our scenario method ==sendMessageReturnX== does a self message-send and returns the value returned by this message send. On the one hand, we want that in our scenario the receiver of both messages is the same. On the other hand, we want that the message send is correctly evaluated to the return value of the activated method.

[[[language=pharo
CHInterpretable >> sendMessageReturnX [
	^ self returnX
]
]]]

Notice that our method ==sendMessageReturnX== and the implementation of the message it sends ==returnX== live in the same class. 
This means that in this first scenario we can concentrate on the stack management and return value of the message sends, without caring too much about the details of the method lookup algorithm. 
For this first version we will define a simple and incomplete yet useful method lookup algorithm.


@@todo SD-Guille I do not get the following paragraph - I could not really understand and I could not fix it. 

In our test we want to ensure that in a ==self== message-send, the receiver of both called and callee methods is the same. 
One way to do that is to mutate the receiver of the first message-send, and access one of its instance variables in the method that is activated by the second message-send.

[[[language=pharo
CHInterpreterTest >> testSelfSend [
	receiver x: 100.
	self 
		assert: (self executeSelector: #sendMessageReturnX) 
		equals: 100
]
]]]

To make this test green, we need to implement the method ==visitMessageNode:==.
Evaluation a message node requires that we recursively evaluate the receiver node, which may be a literal node or a complex expression such as another message-send.
From such an evaluation we obtain the actual receiver object. 
Starting from the receiver, we will lookup the method with the same selector as the message-send. 
In our first implementation we will just fetch the desired method's AST from the receiver's class. 
Finally, we can activate this method with the receiver using ==execute:withReceiver:== the activation will push a new frame to the call-stack with the given receiver, evaluate the method, and eventually return with a value.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method | 
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self execute: method withReceiver: newReceiver
]
]]]


!!! Balancing the Stack

We mentioned earlier that when the execution of a method is finished and the execution returns to its caller method, its frame should be also discarded from the stack. The current implementation clearly does not do it.
Indeed, we also said that our initial implementation of the stack only grows: as shown by the method ==executeMethod:withReceiver:==, our code never pops frames from the stack.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame receiver: anObject.
	^ self visitNode: anAST
]
]]]

To solve this issue, let us write a test showing the problem first.
The idea of this test is that upon return, the frame of the caller method should be restored and with it its receiver. 
If we make that the caller and callee methods have different receiver instances, then this test can be expressed as some expression executed after a message-send returns. SD- I did not get the last part of the sentence.

The following code snippet shows an scenario that fulfills these requirements: it sets an instance variable with some value, sends a message to an object other than ==self== and upon its return it accesses its instance variable again before returning it. Assuming the collaborator object does not modify ==self==, then the result of evaluating this message should be that 1000 is returned.

[[[
CHInterpretable >> setXAndMessage [
		x := 1000.
		collaborator returnX.
		^ x
]
]]]

Our test ==testBalancingStack== executes the message ==setXAndMessage== that should return 1000.

[[[
CHInterpreterTest >> testBalancingStack [
	self
		assert: (self executeSelector: #setXAndMessage)
		equals: 1000
]
]]]

We then finish our setup by extending ==CHInterpretable== to support delegating to a collaborator object.
We add a ==collaborator== instance variable to the class ==CHInterpretable== with its companion accessors. 
This way we will be able to test that the correct object is set and passed around in the example.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator'
	classVariableNames: ''
	package: 'Champollion-Core'

CHInterpretable >> collaborator [
	^ collaborator
]

CHInterpretable >> collaborator: anObject [
	collaborator := anObject
]
]]]

And in the ==setUp== method we pass a collaborator to our initial receiver.

[[[
CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
	receiver collaborator: CHInterpretable new
]
]]]

!!!! Making the test pass

Executing this test breaks because the access to the instance variable ==x== returns nil, showing the limits of our current implementation.  This is due to the fact that evaluating message send ==returnX== creates a new frame with the collaborator as receiver, and since that frame is not popped from of the stack, when the method returns, the access to the ==x== instance variable accesses the one of the uninitialized collaborator instead of our receiver object.

To solve this problem, we should pop the frame when a method activation finishes. 
This way the stack is balanced. 
This is what the new implementation of ==executeMethod:withReceiver:==is doing.

[[[language=pharo
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	self pushNewFrame.
	self topFrame receiver: anObject.
	result := self visitNode: anAST.
	self popFrame.
	^ result
]

CHInterpreter >> popFrame [
	stack pop
]
]]]


!!! Ensuring the receiver is correctly set: an Extra Test

Our previous tests did ensure that messages return the correct value, activate the correct methods, and that the stack grows and shrinks. However, we did not ensure yet that the receiver changes correctly on a message send, and since we do not lose any opportunity to strenghten our trust in our implementation with a new test, let's write a test for it.

The scenario, illustrated in ==changeCollaboratorX== will ask the collaborator to ==store100IntoX==, implemented previosly. In this scenario, we must ensure that the state of the receiver and the collaborator  are indeed separate and that changing the collaborator will not affect the initial receiver's state.

[[[
CHInterpretable >> changeCollaboratorX [
	collaborator store100IntoX
]
]]]

Our test for this scenario is as follows. 
If we give some value to the receiver and collaborator, executing our method should change the collaborator but not the initial receiver.

[[[
CHInterpreterTest >> testInstanceVariableStoreInMethodActivationDoesNotChangeSender [
	receiver x: 200.
	collaborator x: 300.

	"changeCollaboratorX will replace collaborator's x but not the receiver's"
	self executeSelector: #changeCollaboratorX.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 100
]
]]]

To make our test run, we will store as a convenience the collaborator object in an instance variable of the test too.

[[[
TestCase subclass: #CHInterpreterTest
	instanceVariableNames: 'receiver collaborator'
	classVariableNames: ''
	package: 'Champollion-Tests'

CHInterpreterTest >> setUp [
	super setUp.
	receiver := CHInterpretable new.
	collaborator := CHInterpretable new.
	receiver collaborator: collaborator
]
]]]

This test passes, meaning that our implementation already covered correctly this case.
We are ready to continue our journey in message-sends.

!!! Supporting Message Arguments

So far we have worked only with unary messages. Unary messages have no arguments, so the number of programs we can express with them only is rather limited. The next step towards having a full-blown interpreter is to support message arguments, which will open us the door to support binary and keyword messages. From the evaluator point of view, as well as from the AST point of view, we will not distinguish between unary, binary and keyword messages. The parser already takes care about distinguishing them and handling their precedence. Indeed, message nodes in the AST are the same for all kind of messages, they have a selector and a collection of argument nodes. Precedence is then modelled as relationships between the AST nodes.


In addition of simply passing the arguments, from an evaluator point of view, we need to care about evaluation order too. This is particularly important because Pharo is an imperative language where messages can trigger side effects. Evaluating two messages in one order may not have the same result as evaluating them in a different order. Arguments in Pharo are evaluated eagerly after evaluating the receiver expression, but before evaluating the message, from left to right. Once all expressions are evaluated, the resulting objects are send as part of the message-send.

!!! Initial Argument Support

To implement some initial support for arguments, our first scenario is to simply send a message with an argument. For our scenario we already count with one message with an argument: the ==x:== setter. We can then define a method ==changeCollaboratorWithArgument== which uses it.

[[[language=smalltalk
CHInterpretable >> changeCollaboratorWithArgument [
	collaborator x: 500
]
]]]

In the test, we verify that the method evaluation effectively modifies the collaborator object 
as written in ==changeCollaboratorWithArgument==, and not the initial receiver object.

[[[language=smalltalk
CHInterpreterTest >> testArgumentAccess [

	receiver x: 200.
	collaborator x: 300.

	self executeSelector: #changeCollaboratorWithArgument.

	self assert: receiver x equals: 200.
	self assert: collaborator x equals: 500
]
]]]

Since we have not implemented any support for arguments yet, this test should fail.

Implementing argument support requires two main changes:
- On the caller side, we need to evaluate the arguments in the context of the caller method and then store those values in the new frame. 
- On the callee side, when an argument access is evaluated, those accesses will not re-evaluate the expressions in the caller. Instead, argument access will just read the variables pre-stored in the current frame.

Let's start with the second step (the callee side) by defining the method ==visitArgumentNode:== to implement how a method accesses an argument. 
Since all variable reads are concentrated on the scope lookup, we need to add the method scope in the scope chain, and define a ==read:== method for it.

[[[
CHInterpreter >> execute: anAST withReceiver: anObject [
	| result |
  self pushNewFrame.

  "Set up the scope chain"
  self topFrame parentScope: (CHInstanceScope new
		receiver: anObject;
		parentScope: globalScope;
		yourself);
	yourself.

  self topFrame receiver: anObject.
  result := self visitNode: anAST.
  self popFrame.
  ^ result

]
CHInterpreter >> currentScope [
	^ self topFrame
]

CHMethodScope >> scopeDefining: aString [
	(variables includesKey: aString)
		ifTrue: [ ^ self ].

	^ self parentScope scopeDefining: aString
]

CHMethodScope >> read: aString [
	^ variables at: aString
]
]]]

Then we need to update ==visitMessageNode:== to compute the arguments by doing a recursive evaluation, and then use those values during the new method activation.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	newReceiver := self visitNode: aMessageNode receiver.
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

To include arguments in the method activation, let's add a new ==arguments== parameter to our method ==execute:withReceiver:== to get ==execute:withReceiver:withArguments:==. 

In addition to adding the receiver to the new frame representing the execution, we add a binding for each parameter (called unfornately arguments in Pharo AST) with their corresponding value in the argument collection. 
We use the message ==with:do:== to iterate both the parameter list and actual arguments as pairs.

SD - Guille why not adding parameter to the AST like that the book is "correct" we are using tempAt: put: but I'm sure we already defined it.

[[[
CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
  self pushNewFrame.

  "Set up the scope chain"
  self topFrame parentScope: (CHInstanceScope new
		receiver: anObject;
		parentScope: globalScope;
		yourself);
	yourself.

	self topFrame receiver: anObject.
	anAST arguments 
		with: aCollection
		do: [ :arg :value | self topFrame at: arg name put: value ]. 
	result := self visitNode: anAST.
	self popFrame.
	^ result
]
]]]

Instead of just removing the old ==executeMethod:withReceiver:== method, we redefine it calling the new one with a default empty collection of arguments. This method was used as part of our public API so keeping it will avoid migrating extra code and an empty collection of arguments seems like a sensible and practical default.
 
[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject [
	^ self 
		executeMethod: anAST 
		withReceiver: anObject 
		andArguments: #()
]
]]]

Our tests should all pass now.

!!! Refactoring the Terrain

Let's now refactor a bit the existing code to clean it up and expose some existing but hidden functionality. Let us extract the code that accesses ==self== and the frame parameters into two other methods that make more intention revealing that we are accessing values in the current frame.

@@note GP this section does not make too much sense as it is now with the new scopes. But we could refactor the scope creation.

[[[
CHInterpreter >> tempAt: aSymbol put: anInteger [
	self topFrame at: aSymbol put: anInteger
]
]]]

[[[
CHInterpreter >> execute: anAST withReceiver: anObject andArguments: aCollection [
	| result |
	self pushNewFrame.
  
  "Set up the scope chain"
  self topFrame parentScope: (CHInstanceScope new
		receiver: anObject;
		parentScope: globalScope;
		yourself);
	yourself.
  
	self topFrame receiver: anObject.
	anAST arguments 
		with: aCollection
		do: [ :arg :value | self tempAt: arg name put: value ].
	result := self visitNode: anAST.
	self popFrame.
	^ result
]
]]]

!!! Handling Temporaries

Temporary variables, or local variables, are variables that live within the scope of a method's ""execution"".
Memory for such variables is allocated when a method is activated, and released when the method returns.
Because of this property, temporary variables are also called automatic variables in languages like C.

The usual way to implement such temporary variables is to allocate them in the method execution's frame.
This way, when the method returns, the frame is popped and all the values allocated in temporaries are discarded and can be reclaimed.
In other words, we will manage temporaries the same way as we manage parameters.

Our first scenario introducing temporaries will verify the default value of temporaries.
Indeed when temporaries are allocated in Pharo, the execution engine (in this case our evaluator) should make sure these variables are correctly initialized to a default value, in this case ==nil==.

Notice that temporaries cannot be observed from outside the execution of a method unless we halt the evaluation of a method in the middle of the evaluation. Since our testing approach is more like a black-box approach, we need to make our scenarios visible from the outside somehow. Because of these reasons, our tests will rely on returns again, as we did before with literal objects.

[[[
CHInterpretable >> returnUnassignedTemp [
	| temp |
	^ temp
]
]]]

The companion test verifies that the value of a uninitialized temporary is ==nil==.

[[[
CHInterpreterTest >> testUnassignedTempHasNilValue [
	self
		assert: (self executeSelector: #returnUnassignedTemp)
		equals: nil
]
]]]

The current subset of Pharo that we interpret does not contain blocks and their local/temporary variables (We will implement blocks and more complex lexical scopes in a subsequent chapter).
Therefore the temporary variable management we need to implement so far is rather simple.

To make our test pass, we modify the ==execute:withReceiver:andArguments:== method to define the temporaries needed with ==nil== as value.

[[[
CHInterpreter >> executeMethod: anAST withReceiver: anObject andArguments: aCollection [
  | result thisFrame |	
  self pushNewFrame.
  self topFrame parentScope: (CHInstanceScope new
		receiver: anObject;
		parentScope: globalScope;
		yourself);
	yourself.
  
	self topFrame receiver: anObject.
	anAST arguments with: aCollection do: [ :arg :value | self tempAt: arg name put: value ].
	anAST temporaryNames do: [ :tempName | self tempAt: tempName name put: nil ].
	result := self visitNode: anAST body.
	self popFrame.
	^ result
]
]]]

The tests should be pass.

!!! Implementing Temporary Variable Writes

Finally we test that writes to temporary variables are working too.
We define our scenario method ==writeTemporaryVariable==, which defines a temporary variable, assigns to it and returns it. 
An optimizing compiler for this code would be smart enough to do constant propagation of the literal integer and then realize that the temporary is dead code and remove it, leaving us with a method body looking like == ^ 100 ==. 
However, since the parser does not do such optimizations by itself, we are sure that the AST weget contains both the temporary definition, the assignment, and the temporary return.

[[[
CHInterpretable >> writeTemporaryVariable [
	| temp |
	temp := 100.
	^ temp
]
]]]

Its companion test checks that evaluating this method does effectively return 100, meaning that the temporary variable write succeeded, and that ==temp== means the same variable in the assignment and in the access.

[[[
CHInterpreterTest >> testWriteTemporaryVariable [
	self
		assert: (self executeSelector: #writeTemporaryVariable)
		equals: 100
]
]]]


Since temporary variable name resolution is already managed by our method scopes, we just need to implement ==write:withValue:== in it to make all our tests pass.

[[[
  CHMethodScope >> write: aString withValue: aValue [
  	variables at: aString put: aValue
]
]]]


!!! Evaluation Order

The last thing we need to make sure is that arguments are evaluated in the correct order.
The evaluation order in Pharo goes as follows: before evaluating a message, the receiver and all arguments are evaluated. The receiver is evaluated before the arguments. Arguments are evaluated in left-to-right order.

Testing the evaluation order in a black-box fashion as we were doing so far is rather challenging with our current evaluator. Indeed, our evaluator does not yet handle arithmetics, allocations nor other kind of primitive. A simple approach to test is to make a counter out of *Peano Axioms>https://en.wikipedia.org/wiki/Peano_axioms*. The main idea is to implement numbers as sets, where the empty set is the zero, the set that contains the zero is one, the set that contains a one is a two, and so on. The only support we need for this is to extend our literal support for dynamic array literals. The code illustrating the idea follows.

SD I got confused why next loca temporary is called next and not previous.

[[[
CHInterpretable >> initialize [
  super initialize.
  current := { "empty" }.
]
]]]

[[[
CHInterpretable >> next [
  | next |
  "Implement a stream as an increment in terms of Peano axioms.
  See https://en.wikipedia.org/wiki/Peano_axioms"
  next := current.
  current := { current }.
  ^ next
]
]]]

[[[
CHInterpreterTests >> peanoToInt: aPeanoNumber [
	"Helper method to transform a peano number to a normal Pharo integer"
	^ aPeanoNumber
		ifEmpty: [ 0 ]
		ifNonEmpty: [ 1 + (self peanoToInt: aPeanoNumber first) ]
]
]]]

Using this support, we can express our evaluation order scenario and test as follows.
We will add a new instance variable to ==CHInterpretable== to store its evaluation order.
Then, we are going to send a message with many arguments, evaluating for each argument ==self next==.
The message receiving the many arguments will then receive as argument the three generated peano values, that we will return as dynamic literal array. If evaluation order is right, the evaluation order of the receiver should be 0, the evaluation of the first argument should be 1, and so on.

[[[
Object subclass: #CHInterpretable
	instanceVariableNames: 'x collaborator evaluationOrder'
	classVariableNames: ''
	package: 'Champollion-Core'
]]]

[[[
CHInterpretable >> evaluationOrder [
  ^ evaluationOrder
]
]]]

[[[
CHInterpretable >> evaluateReceiver [
  evaluationOrder := self next.
  ^ self
]
]]]

[[[
CHInterpretable >> returnEvaluationOrder [
  ^ self evaluateReceiver
      messageArg1: self next
      arg2: self next
      arg3: self next
]
]]]

[[[
CHInterpretable >> messageArg1: arg1 arg2: arg2 arg3: arg3 [
  ^ {arg1 . arg2 . arg3}
]

CHInterpreterTests >> testEvaluationOrder [
  | argumentEvaluationOrder |
  argumentEvaluationOrder := self executeSelector: #returnEvaluationOrder.

  self assert: (self peanoToInt: receiver evaluationOrder) equals: 0.
  self
    assert: (argumentEvaluationOrder collect: 
		[ :peano | self peanoToInt: peano])
    equals: #(1 2 3)
]
]]]

To make this test green we need to implement previously some new support in our interpreter: writing to temporary variables and dynamic literal arrays.

@@note OK, writing to temporaries is broken in P9. We should do it with an extension method? This is the same problem as before with name resolution...
SD why this is broken? 

[[[
CHInterpreter >> visitArrayNode: aRBArrayNode [
	^ aRBArrayNode statements 
		collect: [ :e | self visitNode: e ] 
		as: Array
]
]]]

At this point our test will fail because the evaluation order is wrong! The receiver was evaluated 4th, after all arguments. 
This is solved by changing the order of evaluation in ==visitMessageNode:==.

[[[
CHInterpreter >> visitMessageNode: aMessageNode [
	| newReceiver method args |
	newReceiver := self visitNode: aMessageNode receiver.
	args := aMessageNode arguments collect: [ :each | self visitNode: each ].
	method := (newReceiver class compiledMethodAt: aMessageNode selector) ast.
	^ self executeMethod: method withReceiver: newReceiver andArguments: args
]
]]]

!!! About Name Conflict Resolution

Inside the scope of a method, statements have access to parameters, temporaries, instance and global variables. A name conflict appears when two variables that should be visible in a method share the same name. In a conflict scenario the language developer needs to device a resolution strategy for these problems, to avoid ambiguities.

For example, consider a method ==m:== that has an argument named ==integer== and defines a temporary variable also named ==integer==. 
How should values of that name be resolved? 
How are assignments resolved? 
A conflict resolution strategy provides a set of deterministic rules to answer these questions and let developers understand what their program do in a non-ambiguous way.

A first simple strategy to avoid conflicts is preventing them at construction time. 
That is, the language should not allow developers to define variables if they generate a name conflict. 
For example, a method should not be able to define a temporary variable with the same name as an instance variable of its class. 
Usually these validations are done once at compile time, and programs that do not follow this rules are rejected.

Another strategy to solve this problem is to allow shadowing. 
That is, we give each variable in our program a priority, and then the actual variable to read or write is looked-up using this priority system.
Typically priorities in these schemas are modelled as lexical scopes. 
Lexical scoping divides a program in a hierarchy of scopes. 
Each scope defines variables and all but the top level scope have a parent scope. 
For example, the top level scope defines global variables, the class scope defines the instance variables, the method scope defines the parameters and temporaries. 
In this way, variable visibility can be defined in terms of a scope: the variables visible in a scope are those defined in the scope or in the parents of the scope. 
Moreover, scoping also gives a conflict resolution strategy: variables defined closer to the current scope in the scope hierarchy have more priority than those defined higher in the scope hierarchy.

@@note should we or not?
In the scope of these first chapters we will not manage conflict resolution explicitly. Name resolution is previously done in the AST semantic analysis upon which we are building our evaluator. This means name resolution is already resolved for us following the Opal compiler semantics: shadowing is forbidden.

!!! About Return

SD: I will write something here

!!! Conclusion

Implementing messages implied modelling the call-stack and keeping it balanced on method returns.
We have seen that a call-stack is made up of frames, each frame representing the activation of a method: it stores the method, receiver, arguments, and temporaries of the method that is executing. When a message takes place, receiver and arguments are evluated in order from left to right, a new frame is created and all values are stored in the frame.

